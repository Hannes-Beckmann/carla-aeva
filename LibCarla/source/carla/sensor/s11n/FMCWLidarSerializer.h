// Copyright Aeva 2024

#pragma once

#include "carla/Debug.h"
#include "carla/Memory.h"
#include "carla/sensor/RawData.h"
#include "carla/sensor/data/FMCWLidarData.h"

namespace carla {
namespace sensor {

class SensorData;

namespace s11n {

/// This class allows the client to access header data, originally set in FMCWLidarData.h.
class FMCWLidarHeaderView {
  /// Use the same indexing enum as FMCWLidarData.h.
  using Index = data::FMCWLidarData::Index;

 public:
  float GetHorizontalAngle() const {
    return reinterpret_cast<const float&>(begin_[Index::HorizontalAngle]);
  }

  uint32_t GetChannelCount() const { return begin_[Index::ChannelCount]; }

  uint32_t GetBeamCount() const { return begin_[Index::BeamCount]; }

  uint32_t GetPointsPerChannel() const { return begin_[Index::PointsPerChannel]; }

  uint32_t GetPointsPerBeam() const { return begin_[Index::PointsPerBeam]; }

 protected:
  friend class FMCWLidarSerializer;

  explicit FMCWLidarHeaderView(const uint32_t* begin) : begin_(begin) {
    DEBUG_ASSERT(begin_ != nullptr);
  }

  const uint32_t* begin_;
};

/// Serializes the data generated by LiDAR sensors.
class FMCWLidarSerializer {
 public:
  static FMCWLidarHeaderView DeserializeHeader(const RawData& data) {
    return FMCWLidarHeaderView{reinterpret_cast<const uint32_t*>(data.begin())};
  }

  static size_t GetHeaderOffset(const RawData& data) {
    (void)data;
    return sizeof(uint32_t) * (data::FMCWLidarData::Index::SIZE);
  }

  template <typename Sensor>
  static Buffer Serialize(const Sensor& sensor, const data::FMCWLidarData& measurement,
                          Buffer&& output);

  static SharedPtr<SensorData> Deserialize(RawData&& data);
};

template <typename Sensor>
inline Buffer FMCWLidarSerializer::Serialize(const Sensor&,
                                                const data::FMCWLidarData& measurement,
                                                Buffer&& output) {
  std::array<boost::asio::const_buffer, 2u> seq = {boost::asio::buffer(measurement._header),
                                                   boost::asio::buffer(measurement._points)};
  output.copy_from(seq);
  return std::move(output);
}

}  // namespace s11n
}  // namespace sensor
}  // namespace carla
