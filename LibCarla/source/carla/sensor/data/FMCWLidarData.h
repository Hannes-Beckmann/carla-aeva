// Copyright Aeva 2024

#pragma once

#include "carla/rpc/Location.h"

#include <cstdint>
#include <numeric>
#include <vector>

namespace carla {
namespace sensor {

namespace s11n {

class FMCWLidarSerializer;
class FMCWLidarHeaderView;

}  // namespace s11n

namespace data {

/// Helper class to store and serialize the data generated by a RawLidar.
///
/// The header of a LiDAR measurement consists of an array of uint32_t's in
/// the following layout
///
///    {
///      Horizontal angle (float),
///      Channel count,
///      Beam count,
///      Point count per Channel,
///      Point count per Beam,
///    }
///
/// In this FMCW Lidar implementation, the number of points per channel and 
/// per beam are the ideal maximum values of the scan pattern. The values do
/// not vary and do not depend on dropoff or blocking hit. An additional valid
/// flag is introduced to track valid hits instead.
///
/// The points are stored in an array of detections, each detection consist of
/// the point detected, the angle between the casted ray and the normal of the
/// object hit, intensity, doppler velocity, the instance, the semantic tag of
/// the object hit, the index of the point within a beam, the index of the beam
/// itself, valid flag, and dynamic flag.
///
///    {
///      Az0, El0, R0, I0, V0, Cos(TH0), obj_idx_0, obj_tag_0, point_idx_0,
///      beam_idx_0, valid_0, dynamic_0
///      ...
///      Azn, Eln, Rn, In, Vn, Cos(THn), obj_idx_n, obj_tag_n, point_idx_n,
///      beam_idx_n, valid_n, dynamic_n
///    }

#pragma pack(push, 1)
class FMCWLidarDetection {
 public:
  float azimuth = 0.0f;
  float elevation = 0.0f;
  float range = 0.0f;
  float intensity = 0.0f;
  float velocity = 0.0f;
  float cos_inc_angle = 0.0f;
  uint32_t object_idx = 0;
  uint32_t object_tag = 0;
  uint32_t point_idx = 0;
  uint8_t beam_idx = 0;
  uint8_t valid = 0;
  uint8_t dynamic = 0;

  FMCWLidarDetection() = default;

  FMCWLidarDetection(float az, float el, float r, float intensity, float velocity, float cos_theta,
                        uint32_t obj_idx, uint32_t obj_tag, uint32_t pt_idx, uint8_t beam_idx, uint8_t valid, uint8_t dynamic)
      : azimuth(az),
        elevation{el},
        range{r},
        intensity{intensity},
        velocity{velocity},
        cos_inc_angle{cos_theta},
        object_idx{obj_idx},
        object_tag{obj_tag},
        point_idx{pt_idx},
        beam_idx{beam_idx},
        valid{valid},
        dynamic{dynamic} {}

  void WritePlyHeaderInfo(std::ostream& out) const {
    out << "property float32 Az\n"
           "property float32 El\n"
           "property float32 R\n"
           "property float32 I\n"
           "property float32 V\n"
           "property float32 CosAngle\n"
           "property uint32 ObjIdx\n"
           "property uint32 ObjTag\n"
           "property uint32 PointIdx\n"
           "property uint8_t BeamIdx\n"
           "property uint8_t Valid\n"
           "property uint8_t Dynamic";
  }

  void WriteDetection(std::ostream& out) const {
    out << azimuth << ' ' << elevation << ' ' << range << ' ' << intensity << ' ' << velocity
        << ' ' << cos_inc_angle << ' ' << object_idx << ' ' << object_tag << ' ' << point_idx
        << ' ' << beam_idx << ' ' << valid << ' ' << dynamic;
  }
};
#pragma pack(pop)

class FMCWLidarData {
  static_assert(sizeof(float) == sizeof(uint32_t), "Invalid float size");

 protected:
  enum Index : size_t {
    HorizontalAngle,
    ChannelCount,
    BeamCount,
    PointsPerChannel,
    PointsPerBeam,
    SIZE
  };

 public:
  explicit FMCWLidarData(uint32_t channel_count = 0u, uint32_t beam_count = 0u, uint32_t points_per_channel = 0u, uint32_t points_per_beam = 0u)
      : _header(Index::SIZE, 0u) {
    _header[Index::ChannelCount] = channel_count;
    _header[Index::BeamCount] = beam_count;
    _header[Index::PointsPerChannel] = points_per_channel;
    _header[Index::PointsPerBeam] = points_per_beam;

    DEBUG_ASSERT(GetChannelCount() * GetPointsPerChannel() == GetBeamCount() * GetPointsPerBeam());
  }

  FMCWLidarData& operator=(FMCWLidarData&&) = default;

  virtual ~FMCWLidarData() {}

  float GetHorizontalAngle() const {
    return reinterpret_cast<const float&>(_header[Index::HorizontalAngle]);
  }

  void SetHorizontalAngle(float angle) {
    std::memcpy(&_header[Index::HorizontalAngle], &angle, sizeof(uint32_t));
  }

  uint32_t GetChannelCount() const { return _header[Index::ChannelCount]; }

  uint32_t GetBeamCount() const { return _header[Index::BeamCount]; }

  uint32_t GetPointsPerChannel() const { return _header[Index::PointsPerChannel]; }

  uint32_t GetPointsPerBeam() const { return _header[Index::PointsPerBeam]; }

  // Clear all data points.
  void ResetMemory() {
    _points.clear();
    _points.reserve(GetChannelCount() * GetPointsPerChannel());
  }


  void WritePointSync(FMCWLidarDetection& detection) {
    _points.emplace_back(detection);
  }

 protected:
  std::vector<uint32_t> _header;

 private:
  std::vector<FMCWLidarDetection> _points;

  friend class s11n::FMCWLidarHeaderView;
  friend class s11n::FMCWLidarSerializer;
};

}  // namespace data
}  // namespace sensor
}  // namespace carla
